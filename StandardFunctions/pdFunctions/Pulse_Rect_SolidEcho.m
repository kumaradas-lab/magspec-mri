function pulseData = Pulse_Rect_SolidEcho(HW, Center, Pulse, varargin)
%% Create a RF pulse sequence with rect pulses for a solid echo
%
%   pulseData = Pulse_Rect_SolidEcho(HW, Center, Pulse)
% or:
%   pulseData = Pulse_Rect_SolidEcho(HW, Center, Bandwidth, FlipAngle, MaxNumberOfSegments, MaxLength, Frequency, Phase)
% additionally:
%   excitationAngleFactor = Pulse_Rect_SolidEcho(HW, 'Amp')
%   bandwidthFactor = Pulse_Rect_SolidEcho(HW, 'Time')
%
% A solid echo is generated by applying two 90 degree pulses separated by the
% time tau. The phase of the second pulse is usually 90 degrees to the first
% pulse. If tau is sufficiently short (usually shorter than the inverse of the
% response bandwidth of the pulse), the spin state of the first excitation pulse
% refocuses at time tau after the second 90 degree pulse. This allows to acquire
% the "refocused FID" (i.e. the "solid echo") of samples with short T2*.
%
%
% INPUT:
%
%   HW      HW structure
%   Center  The center of the refocussed spin system in seconds (tRep). This
%           definition allows it to replace a "normal" excitation pulse with
%           this solid echo pulse.
%   Pulse   A structure with the following fields (if omitted or empty, default
%           values are used):
%     FlipAngle
%             The total (effective) flip angle of the pulse in radians (or the
%             units defined by FlipAngleFullTurn). It is used to set an
%             appropriate pulse amplitude (default: pi/2).
%     FlipAngleFullTurn
%             Value that defines a full turn in FlipAngle units (e.g. 360 for
%             degrees, or 2*pi for radians, default: 2*pi).
%     MaxNumberOfSegments
%             Maximum number of segments of the pulse (default: 1).
%     MaxLength
%             Maximum length of the pulse in seconds (default: Inf).
%     Frequency
%             Frequency of the rf pulse in Hz (default: HW.fLarmor).
%     Phase
%             "Local" RF phase of the pulse with respect to the overall sequence
%             in degrees (default: 0).
%     Bandwidth
%             Bandwidth of the pulse in Hz
%             (default: max(1/Pulse.MaxLength, 2e3) )
%     tauSolid
%             Time between the first (excitation) and second ("refocusing") 90
%             degree pulses in seconds. The first (excitation) pulse centers at
%             Center-2*tauSolid, the second ("refocusing") pulse centers at
%             Center-tauSolid. (Default: 2*HW.tFlip90Def)
%     PhaseSolidInversionOffset
%             Phase offset of the second ("refocusing") pulse with respect to
%             the first (excitation) pulse in degrees. (Default: 90)
%
%
% OUTPUT:
%
%   pulseData
%          A structure with the following fields:
%     Start   Column vector with the start times of each component/block in
%             seconds (tRep).
%     Amplitude
%             Column vector with the amplitudes of each component/block in
%             Tesla.
%     Duration
%             Column vector with the durations of each component/block in
%             seconds.
%     Frequency
%             Column vector with the frequencies of each component/block in Hz.
%     Phase
%             Column vector with the phases in degrees of each component/block
%             with respect to the overall sequence.
%     tCenterOffset
%             Offset between the center of the 90 degrees pulses and "Center"
%             (i.e., the time of the expected solid echo maximum).
%
%
% The additional syntax is used to return the amplitude and bandwidth factors.
% The "excitationAngleFactor" is the factor that must be applied to the
% amplitude of this pulse to have the same excitation angle as a rect pulse of
% the same length. The "bandwidthFactor" is the factor that must be applied to
% the duration of the pulse to have the same bandwidth (FWHM) as a rect pulse.
%
% ------------------------------------------------------------------------------
% (C) Copyright 2020-2024 Pure Devices GmbH, Wuerzburg, Germany
% www.pure-devices.com
% ------------------------------------------------------------------------------

%% check input
if nargin == 2
  % short path (additional syntax)
  if strcmp(Center, 'Amp')
    pulseData = 1;
  elseif strcmp(Center, 'Time')
    pulseData = 1;
  else
    pulseData = NaN;
  end
  return;
end

%% Convert from syntax (2) to syntax (1)
if nargin < 3, Pulse = []; end
if ~isstruct(Pulse), Pulse = struct('Bandwidth', Pulse); end
if nargin > 3, Pulse.FlipAngle = varargin{1}; end
if nargin > 4, Pulse.MaxNumberOfSegments = varargin{2}; end
if nargin > 5, Pulse.MaxLength = varargin{3}; end
if nargin > 6, Pulse.Frequency = varargin{4}; end
if nargin > 7, Pulse.Phase = varargin{5}; end


%% default values
Pulse = set_EmptyField(Pulse, 'FlipAngle', pi/2);
Pulse = set_EmptyField(Pulse, 'FlipAngleFullTurn', 2*pi);
Pulse = set_EmptyField(Pulse, 'MaxNumberOfSegments', 3);  % first pulse - pause - second pulse
Pulse = set_EmptyField(Pulse, 'MaxLength', Inf);
Pulse = set_EmptyField(Pulse, 'Frequency', HW.fLarmor);
Pulse = set_EmptyField(Pulse, 'Phase', 0);
Pulse = set_EmptyField(Pulse, 'Bandwidth', max(1/Pulse.MaxLength, 2e3));  % FIXME: Is this a sensible default?
Pulse = set_EmptyField(Pulse, 'iDevice', 1);
% pulse shape specific settings
if isemptyfield(Pulse, 'tauSolid'), Pulse.tauSolid = 2*HW.tFlip90Def; end
if isemptyfield(Pulse, 'PhaseSolidInversionOffset'), Pulse.PhaseSolidInversionOffset = 90; end


%% rect pulses for a solid echo
% Use gamma that better matches the frequency of the pulse
% FIXME: Could this be an issue with (very) off-center slice pulses?
if abs(Pulse.Frequency - HW.fLarmorX) < abs(Pulse.Frequency - HW.fLarmor)
  tFlipPi = pi/HW.GammaX / HW.TX(Pulse.iDevice).AmpDef;
else
  tFlipPi = HW.TX(Pulse.iDevice).Amp2FlipPiIn1Sec / HW.TX(Pulse.iDevice).AmpDef;
end

BlockLength = 1/Pulse.Bandwidth;

gain = HW.TX(Pulse.iDevice).AmpDef * 2*tFlipPi * ...
  (Pulse.FlipAngle/Pulse.FlipAngleFullTurn) / BlockLength;

if Pulse.MaxLength + 1/HW.TX(Pulse.iDevice).fSample < BlockLength
  error('PD:Pulse_Rect_SolidEcho:MaxLengthTooShort', ...
    'MaxLength of rf pulse is %.3f %cs too short.', ...
    (BlockLength - Pulse.MaxLength)*1e6, char(181));
end

if Pulse.MaxNumberOfSegments < 3
  error('MaxNumberOfSegments must be at least 3.');
end

% pulseData.Start = [-2*Pulse.tauSolid; -Pulse.tauSolid] + Center - BlockLength/2;
% pulseData.Duration = [BlockLength; BlockLength];
pulseData.Start = [-2*Pulse.tauSolid; -2*Pulse.tauSolid+BlockLength; -Pulse.tauSolid] + ...
  Center - BlockLength/2;
pulseData.Duration = [diff(pulseData.Start); BlockLength];
pulseData.Start(2) = [];
pulseData.Duration(2) = [];
pulseData.Amplitude = [gain; gain];
pulseData.Frequency = zeros(size(pulseData.Start)) + Pulse.Frequency;
pulseData.Phase = [0; Pulse.PhaseSolidInversionOffset] + Pulse.Phase;

pulseData.tCenterOffset = Center - 3/2*Pulse.tauSolid;  % center of the RF pulses

end
