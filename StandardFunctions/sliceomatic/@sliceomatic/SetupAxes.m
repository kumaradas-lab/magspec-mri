function d = SetupAxes(this, d, xmesh, ymesh, zmesh)
%% Create the figure window to be used by the sliceomatic GUI.
%
%     d = this.SetupAxes(d, xmesh, ymesh, zmesh)
%
% INPUT:
%   d         The app data to attach to the figure.
%   [xyz]mesh The vectors define a mesh that d.data falls into.
%
%
% Copyright 2000, 2001, 2002, 2003, 2004, 2005 The MathWorks Inc
%
% ------------------------------------------------------------------------------
% (C) Copyright 2016-2020 Pure Devices GmbH, Wuerzburg, Germany
% www.pure-devices.com
% ------------------------------------------------------------------------------

%% Check variables
narginchk(5, 5);

%% Init sliceomatic
if isempty(this.hFigure)
  if isempty(this.hParent)
    this.hFigure = figure();
  else
    this.hFigure = ancestor(this.hParent, 'figure');
  end
end
if isempty(this.hParent), this.hParent = this.hFigure; end

if this.hParent == this.hFigure
  this.hFigure = figure(this.hFigure);
  clf(this.hFigure, 'reset')
  set(this.hFigure, 'Name', 'Sliceomatic');
end

%% trigger delete function of previous sliceomatic in parent
d_old = getappdata(this.hParent, 'sliceomatic');
if ~isempty(d_old) && ishghandle(d_old.axmain, 'axes')
  delete(d_old.axmain);
end

%% Set up main axes
lim = [min(d.data(isfinite(d.data))), max(d.data(isfinite(d.data)))];
if isempty(lim)
  lim = [-1, 1];
end
if lim(1) == lim(2)
  lim(1) = 0.9*lim(1);
  lim(2) = 1.1*lim(2);
end

if ~isnan(xmesh)
  % Set axis orientation
  xdir = 'normal';
  ydir = 'normal';
  zdir = 'normal';
  if ~issorted(xmesh)
    xmesh = flip(xmesh, 2);
    xdir = 'reverse';
  end
  if ~issorted(ymesh)
    ymesh = flip(ymesh, 2);
    ydir = 'reverse';
  end
  % This should not be the case for medical images
  if ~issorted(zmesh)
    zmesh = flip(zmesh, 2);
    zdir = 'reverse';
  end

  % Update data structure
  this.hAxes = axes('Tag', 'MainAxes', ...
    'Units', 'pixels', ...
    'Box', 'on', ...
    'YLim', [ymesh(1), ymesh(end)], ...
    'XLim', [xmesh(1), xmesh(end)], ...
    'ZLim', [zmesh(1), zmesh(end)], ...
    'CLim', lim, ...
    'ALim', lim, ...
    'Parent', this.hParent, ...
    'ActivePositionProperty', 'outerposition');
  % Set axes direction
  set(this.hAxes, 'XDir', xdir, 'YDir', ydir, 'ZDir', zdir);
else
  this.hAxes = axes('Tag', 'MainAxes', ...
    'Units', 'pixels', ...
    'Box', 'on', ...
    'YLim', [1, size(d.data, 1)], ...
    'XLim', [1, size(d.data, 2)], ...
    'ZLim', [1, size(d.data, 3)], ...
    'CLim', lim, ...
    'ALim', lim, ...
    'Parent', this.hParent, ...
    'ActivePositionProperty', 'outerposition');
end
set(this.hAxes, 'DeleteFcn', @this.AxesDeleteFcn);
set(this.hFigure, 'DeleteFcn', @this.FigureDeleteFcn); % FIXME: Should we care to restore a previous delete function when we are done?

activelabel(this.hAxes, 'XLabel', 'X');
activelabel(this.hAxes, 'YLabel', 'Y');
activelabel(this.hAxes, 'ZLabel', 'Z');
%activelabel(this.hAxes, 'Title', 'Data');
daspect(this.hAxes, [1, 1, 1]);
view(this.hAxes, 3);

if verLessThan('matlab', '8.4')
  axis(this.hAxes, 'tight', 'vis3d');
else
  axis(this.hAxes, 'vis3d');
end

hold(this.hAxes, 'all');
grid(this.hAxes, 'on');

%% Set up the four controller axes
this.hSliderX = axes(...
  'Tag', 'Slider X', ...
  'Units', 'pixels', ...
  'Box', 'on', ...
  'YTick', [], 'XGrid', 'on', 'XAxisLocation', 'top', ...
  'ZLim', [-2 1 ], ...
  'Layer', 'top', ...
  'TickLength', [0 0], ...
  'Parent', this.hParent);
d.pxx = patch(...
  'FaceColor', [1 1 1], ...
  'EdgeColor', 'none', ...
  'HitTest', 'off', ...
  'Parent', this.hSliderX);
setappdata(this.hSliderX, 'motionpointer', 'SOM top');
this.hSliderY = axes(...
  'Tag', 'Slider Y', ...
  'Units', 'pixels', ...
  'Box', 'on', ...
  'XTick', [], 'YGrid', 'on', ...
  'ZLim', [-2 1 ], ...
  'Layer', 'top', ...
  'TickLength', [0 0], ...
  'Parent', this.hParent);
d.pxy = patch(...
  'FaceColor', [1 1 1], ...
  'EdgeColor', 'none', ...
  'HitTest', 'off', ...
  'Parent', this.hSliderY);
setappdata(this.hSliderY, 'motionpointer', 'SOM left');
this.hSliderZ = axes(...
  'Tag', 'Slider Z', ...
  'Units', 'pixels', ...
  'Box', 'on', ...
  'XTick', [], 'YGrid', 'on', 'YAxisLocation', 'right', ...
  'ZLim', [-2 1 ], ...
  'Layer', 'top', ...
  'TickLength', [0 0], ...
  'Parent', this.hParent);
d.pxz = patch(...
  'FaceColor', [1 1 1], ...
  'EdgeColor', 'none', ...
  'HitTest', 'off', ...
  'Parent', this.hSliderZ);
setappdata(this.hSliderZ, 'motionpointer', 'SOM right');
this.hSliderIso = axes(...
  'Tag', 'Slider_ISO', ...
  'Units', 'pixels',...
  'Box', 'on', ...
  'YTick', [], 'XGrid', 'off', 'YGrid', 'off', ...
  'XAxisLocation', 'bottom', ...
  'ZLim', [-1 1], ...
  'Layer', 'top', ...
  'TickLength', [0 0], ...
  'Parent', this.hParent);
setappdata(this.hSliderIso, 'motionpointer', 'SOM bottom');
% set([d.axx d.axy d.axz d.axiso], 'HandleVisibility', 'off');

% FIXME: Remove these duplications once sliceomatic is completely objectified
d.axmain = this.hAxes; % maybe keep this one.
d.handleFigure = this.hFigure;
d.handleParent = this.hParent;
d.axx = this.hSliderX;
d.axy = this.hSliderY;
d.axz = this.hSliderZ;
d.axiso = this.hSliderIso;

setappdata(this.hParent, 'sliceomatic', d);

%% Set up the default sliceomatic controllers
if ~isnan(xmesh)
  slicecontrols(this.hParent, 1, xmesh, ymesh, zmesh, xdir, ydir, zdir);
else
  slicecontrols(this.hParent, 1);
end

isocontrols(this.hParent, 1);

%% parent size changed function
if verLessThan('matlab', '8.4') % before R2014b
  d.oldResizeFcn = get(this.hParent, 'ResizeFcn');
  set(this.hParent, 'ResizeFcn', @(hObject,evtdata) this.SizeChangedFcn());
else
  d.oldSizeChangedFcn = get(this.hParent, 'SizeChangedFcn');
  set(this.hParent, 'SizeChangedFcn', @(hObject,evtdata) this.SizeChangedFcn());
end

%% Button Down Functions
set(this.hSliderX,   'ButtonDownFcn', @(hObject, eventData) this.callbacks('Xnew'));
set(this.hSliderY,   'ButtonDownFcn', @(hObject, eventData) this.callbacks('Ynew'));
set(this.hSliderZ,   'ButtonDownFcn', @(hObject, eventData) this.callbacks('Znew'));
set(this.hSliderIso, 'ButtonDownFcn', @(hObject, eventData) this.callbacks('ISO'));

% store old button down and datacursormode update functions in figure
% for possible restoring
if ~isappdata(this.hFigure, 'sliceomatic_oldbdf')
  oldbdf.zoom = get(zoom(this.hFigure), 'ButtonDownFilter');
  oldbdf.pan = get(pan(this.hFigure), 'ButtonDownFilter');
  oldbdf.rotate3d = get(rotate3d(this.hFigure), 'ButtonDownFilter');
  setappdata(this.hFigure, 'sliceomatic_oldbdf', oldbdf);
end
if ~isappdata(this.hFigure, 'sliceomatic_olddcmuf')
  olddcmuf = get(datacursormode(this.hFigure), 'UpdateFcn');
  setappdata(this.hFigure, 'sliceomatic_olddcmuf', olddcmuf);
end

set(zoom(this.hFigure),     'ButtonDownFilter', @(obj,eventdata) ButtonDownFilterFcn(this.hParent));
set(pan(this.hFigure),      'ButtonDownFilter', @(obj,eventdata) ButtonDownFilterFcn(this.hParent));
set(rotate3d(this.hFigure), 'ButtonDownFilter', @(obj,eventdata) ButtonDownFilterFcn(this.hParent));

%% Allow handling of multiple data cursor update functions
DataCursorUpdateFcns = getappdata(this.hFigure, 'DataCursorUpdateFcns');
DataCursorUpdateFcns.sliceomatic = @(pointDataTip, eventData) DatacursorUpdateFcn(pointDataTip, eventData);
setappdata(this.hFigure, 'DataCursorUpdateFcns', DataCursorUpdateFcns);

set(datacursormode(this.hFigure), 'UpdateFcn',  @DataCursorUpdateFcnHandler);

%% Set up WindowButtonMotionFcn
% Before setting the WindowButtonMotionFcn, mark as not yet completely
% loaded as some handles won't be valid until after figure is initialized
d.displayComplete = false;
setappdata(this.hParent, 'sliceomatic', d);
% Set up our motion function before cameratoolbar is active.
d.motionmetaslice = [];
if ~isappdata(this.hFigure, 'sliceomatic_oldwbmf')
  oldwbmf = get(this.hFigure, 'WindowButtonMotionFcn');
  setappdata(this.hFigure, 'sliceomatic_oldwbmf', oldwbmf);
  if ~isempty(oldwbmf) && ~(isequal(oldwbmf, @sliceomaticmotion) || ...
      (iscell(oldwbmf) && isequal(oldwbmf{1}, @sliceomaticmotion)))
    warning('sliceomatic:OverwriteWindowButtonMotionFcn', ...
      'WindowButtonMotionFcn is overwritten by sliceomatic');
  end
  set(this.hFigure, 'WindowButtonMotionFcn', {@sliceomaticmotion, this.hParent});
end

%% decorations
if strcmp(d.showtoolbars, 'on')
  % Try setting up the camera toolbar
  d = figtoolbar(d);
end

d = this.figmenus(d);

% Color and alpha maps
this.colormapPanel = uipanel(this.hParent, ...
  'Tag',        'Colormap_Panel', ...
  'BorderType', 'none', ...
  'Units',      'pixels');
d.colormaptitle = uicontrol(this.colormapPanel, ...
  'Tag',      'Colormap_Text', ...
  'Style',    'text', ...
  'String',   'Colormap', ...
  'Units',    'normalized', ...
  'Position', [0 .5 1 .4]);
colormap_strings = {'jet', 'hsv', 'hot', 'cool', ...
  'spring', 'summer', 'autumn', 'winter', ...
  'gray', 'bone', 'copper', 'pink', 'lines', 'prism', 'flag', 'rand'};
if ~verLessThan('matlab', '8.4')
  % new default colormap in Matlab R2014b
  colormap_strings = [{'parula'}, colormap_strings];
end
if ~isdeployed()
  % "colormapeditor" tool doesn't work if deployed
  colormap_strings = [colormap_strings, {'custom'}];
end
d.colormapdropdown = uicontrol(this.colormapPanel, ...
  'Tag',      'Colormap_popupmenu', ...
  'Style',    'popupmenu', ...
  'String',   colormap_strings, ...
  'Callback', @(hObject, eventData) this.callbacks('colormap'), ...
  'Units',    'normalized', ...
  'Position', [0 0 1 .5]);

this.alphamapPanel = uipanel(this.hParent, ...
  'Tag',        'Alphamap_Panel', ...
  'BorderType', 'none', ...
  'Units',      'pixels');
d.alphamaptitle = uicontrol(this.alphamapPanel, ...
  'Tag',      'Alphamap_Text', ...
  'Style',    'text', ...
  'String',   'Transparency', ...
  'Units',    'normalized', ...
  'Position', [0 .5 1 .4]);
d.alphamapdropdown = uicontrol(this.alphamapPanel, ...
  'Tag',      'Alphamap_popupmenu', ...
  'Style',    'popupmenu', ...
  'String',   {'rampup', 'rampdown', 'vup', 'vdown', 'rand'}, ...
  'Callback', @(hObject, eventData) this.callbacks('alphamap'), ...
  'Units',    'normalized', ...
  'Position', [0 0 1 .5]);

this.orientationPanel = uipanel(this.hParent, ...
  'Tag',        'Orientation_Panel', ...
  'BorderType', 'none', ...
  'Units',      'pixels');
d.orientationtitle = uicontrol(this.orientationPanel, ...
  'Tag',      'Orientation_Text', ...
  'Style',    'text', ...
  'String',   'Orientation', ...
  'Units',    'normalized', ...
  'Position', [0 .5 1 .4]);
d.orientationdropdown = uicontrol(this.orientationPanel, ...
  'Tag',      'Orientation_popupmenu', ...
  'Style',    'popupmenu', ...
  'String',   {'default', 'X-Y', 'X-Z', 'Y-Z'}, ...
  'Callback', @(hObject, eventData) this.callbacks('orientation'), ...
  'Units',    'normalized', ...
  'Position', [0 0 1 .5]);

if verLessThan('matlab', '8.4') % before R2014b
  if ishghandle(this.hParent, 'figure')
    parentColor = get(this.hParent, 'Color');
  elseif ishghandle(this.hParent, 'uipanel')
    parentColor = get(this.hParent, 'BackgroundColor');
  else
    warning('sliceomatic:unsupportedParent', ...
      'Parents of type "%s" not supported', get(this.hParent, 'Type'))
  end
  set([this.colormapPanel, d.colormaptitle, this.alphamapPanel, d.alphamaptitle], ...
    'BackgroundColor', parentColor);
end

% Data tip thingydoo
d.tip = text('Visible', 'off', 'FontName', 'Helvetica', 'FontSize', 10, ...
  'Color', 'black');
try
  % Try R13 new feature
  set(d.tip, 'BackgroundColor', [1 1 .8], 'EdgeColor', [.5 .5 .5], ...
    'Margin', 5);
end

set(this.hFigure, 'NextPlot', 'new');
set(this.hAxes, 'NextPlot', 'replace');


%% initialize everything and mark as loaded
setappdata(this.hParent, 'sliceomatic', d);
if ~this.isSaved
  this.SizeChangedFcn();
  drawnow();
end
d.displayComplete = true;

end
